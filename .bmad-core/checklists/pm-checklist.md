# 产品经理 (PM) 需求检查清单 (Product Manager (PM) Requirements Checklist)

此检查清单作为确保产品需求文档 (PRD) 和 Epic 定义完整、结构良好并适当范围用于 MVP 开发的综合框架。PM 应在产品定义过程中系统性地处理每个项目。

[[LLM: 初始化指令 - PM 检查清单

在继续此检查清单之前，确保您可以访问：

1. prd.md - 产品需求文档（检查 docs/prd.md）
2. 任何用户研究、市场分析或竞争分析文档
3. 业务目标和战略文档
4. 任何现有的 epic 定义或用户故事

重要提示：如果 PRD 缺失，在继续之前立即询问用户其位置或内容。

验证方法：

1. 以用户为中心 - 每个需求都应该与用户价值相关
2. MVP 焦点 - 确保范围真正最小化但可行
3. 清晰度 - 需求应该明确且可测试
4. 完整性 - 涵盖产品愿景的所有方面
5. 可行性 - 需求在技术上可实现

执行模式：
询问用户是否想要通过检查清单：

- 逐节（交互模式）- 审查每个部分，呈现发现，在继续之前获得确认
- 一次性全部（综合模式）- 完成完整分析并在最后呈现综合报告]]

## 1. 问题定义和上下文 (PROBLEM DEFINITION & CONTEXT)

[[LLM: 任何产品的基础都是清晰的问题陈述。在审查此部分时：

1. 验证问题是真实的且值得解决
2. 检查目标受众是具体的，而不是"所有人"
3. 确保成功指标是可测量的，而不是模糊的愿望
4. 寻找用户研究的证据，而不仅仅是假设
5. 确认问题-解决方案契合是逻辑的]]

### 1.1 问题陈述

- [ ] 清晰阐明要解决的问题
- [ ] 识别谁经历此问题
- [ ] 解释为什么解决此问题很重要
- [ ] 量化问题影响（如果可能）
- [ ] 与现有解决方案的区别

### 1.2 业务目标和成功指标

- [ ] 定义了具体、可测量的业务目标
- [ ] 建立了明确的成功指标和 KPI
- [ ] 指标与用户和业务价值相关
- [ ] 识别了基线测量（如适用）
- [ ] 指定了实现目标的时间框架

### 1.3 用户研究和洞察

- [ ] 明确定义了目标用户角色
- [ ] 记录了用户需求和痛点
- [ ] 总结了用户研究发现（如果有）
- [ ] 包括竞争分析
- [ ] 提供了市场上下文

## 2. MVP 范围定义 (MVP SCOPE DEFINITION)

[[LLM: MVP 范围至关重要 - 太多会浪费资源，太少无法验证。检查：

1. 这真正是最小的吗？挑战每个功能
2. 每个功能是否直接解决核心问题？
3. "锦上添花"是否与"必须拥有"明确分离？
4. 包含/排除的理由是否记录？
5. 能在目标时间框架内交付吗？]]

### 2.1 核心功能

- [ ] 基本功能与锦上添花明确区分
- [ ] 功能直接解决定义的问题陈述
- [ ] 每个 Epic 都与特定用户需求相关
- [ ] 从用户角度描述功能和故事
- [ ] 定义了成功的最低要求

### 2.2 范围边界

- [ ] 明确阐明什么超出范围
- [ ] 包括未来增强部分
- [ ] 记录了范围决策的理由
- [ ] MVP 最小化功能同时最大化学习
- [ ] 范围已经过多次审查和优化

### 2.3 MVP 验证方法

- [ ] 定义了测试 MVP 成功的方法
- [ ] 计划了初始用户反馈机制
- [ ] 指定了超越 MVP 的标准
- [ ] 阐明了 MVP 的学习目标
- [ ] 设定了时间线期望

## 3. 用户体验需求 (USER EXPERIENCE REQUIREMENTS)

[[LLM: UX 需求桥接用户需求和技术实施。验证：

1. 用户流程完全覆盖主要用例
2. 识别了边界情况（即使被推迟）
3. 可访问性不是事后考虑
4. 性能期望是现实的
5. 计划了错误状态和恢复]]

### 3.1 用户旅程和流程

- [ ] 记录了主要用户流程
- [ ] 识别了每个流程的入口和出口点
- [ ] 映射了决策点和分支
- [ ] 突出了关键路径
- [ ] 考虑了边界情况

### 3.2 可用性需求

- [ ] 记录了可访问性考虑
- [ ] 指定了平台/设备兼容性
- [ ] 从用户角度定义了性能期望
- [ ] 概述了错误处理和恢复方法
- [ ] 识别了用户反馈机制

### 3.3 UI 需求

- [ ] 概述了信息架构
- [ ] 识别了关键 UI 组件
- [ ] 引用了视觉设计指南（如适用）
- [ ] 指定了内容需求
- [ ] 定义了高级导航结构

## 4. 功能需求 (FUNCTIONAL REQUIREMENTS)

[[LLM: 功能需求必须足够清晰以便实施。检查：

1. 需求专注于什么而不是如何（无实施细节）
2. 每个需求都是可测试的（QA 如何验证？）
3. 依赖关系是明确的（什么需要先构建？）
4. 需求使用一致的术语
5. 复杂功能分解为可管理的部分]]

### 4.1 功能完整性

- [ ] 记录了 MVP 的所有必需功能
- [ ] 功能有清晰、以用户为中心的描述
- [ ] 指示了功能优先级/关键性
- [ ] 需求是可测试和可验证的
- [ ] 识别了功能之间的依赖关系

### 4.2 需求质量

- [ ] 需求具体且明确
- [ ] 需求专注于什么而不是如何
- [ ] 需求使用一致的术语
- [ ] 复杂需求分解为更简单的部分
- [ ] 最小化或解释了技术术语

### 4.3 用户故事和验收标准

- [ ] 故事遵循一致格式
- [ ] 验收标准是可测试的
- [ ] 故事大小适当（不太大）
- [ ] 故事尽可能独立
- [ ] 故事包括必要的上下文
- [ ] 在相关后端/数据故事的 AC 中定义了本地可测试性要求（例如，通过 CLI）

## 5. 非功能需求 (NON-FUNCTIONAL REQUIREMENTS)

### 5.1 性能需求

- [ ] 定义了响应时间期望
- [ ] 指定了吞吐量/容量需求
- [ ] 记录了可扩展性需求
- [ ] 识别了资源利用约束
- [ ] 设定了负载处理期望

### 5.2 安全和合规

- [ ] 指定了数据保护需求
- [ ] 定义了身份验证/授权需求
- [ ] 记录了合规需求
- [ ] 概述了安全测试需求
- [ ] 解决了隐私考虑

### 5.3 可靠性和弹性

- [ ] 定义了可用性需求
- [ ] 记录了备份和恢复需求
- [ ] 设定了容错期望
- [ ] 指定了错误处理需求
- [ ] 包括维护和支持考虑

### 5.4 技术约束

- [ ] 记录了平台/技术约束
- [ ] 概述了集成需求
- [ ] 识别了第三方服务依赖项
- [ ] 指定了基础设施需求
- [ ] 识别了开发环境需求

## 6. Epic 和故事结构 (EPIC & STORY STRUCTURE)

### 6.1 Epic 定义

- [ ] Epics 代表功能的内聚单元
- [ ] Epics 专注于用户/业务价值交付
- [ ] 明确阐明了 Epic 目标
- [ ] Epics 大小适合增量交付
- [ ] 识别了 Epic 序列和依赖关系

### 6.2 故事分解

- [ ] 故事分解为适当大小
- [ ] 故事有清晰、独立的价值
- [ ] 故事包括适当的验收标准
- [ ] 记录了故事依赖关系和序列
- [ ] 故事与 Epic 目标对齐

### 6.3 第一个 Epic 完整性

- [ ] 第一个 Epic 包括所有必要的设置步骤
- [ ] 解决了项目脚手架和初始化
- [ ] 包括核心基础设施设置
- [ ] 解决了开发环境设置
- [ ] 早期建立了本地可测试性

## 7. 技术指导 (TECHNICAL GUIDANCE)

### 7.1 架构指导

- [ ] 提供了初始架构方向
- [ ] 明确传达了技术约束
- [ ] 识别了集成点
- [ ] 突出了性能考虑
- [ ] 阐明了安全需求
- [ ] 为架构深度分析标记了已知的高复杂性或技术风险领域

### 7.2 技术决策框架

- [ ] 提供了技术选择的决策标准
- [ ] 阐明了关键决策的权衡
- [ ] 记录了选择主要方法而非考虑替代方案的理由（对于关键设计/功能选择）
- [ ] 突出了不可协商的技术需求
- [ ] 识别了需要技术调查的领域
- [ ] 提供了技术债务方法的指导

### 7.3 实施考虑

- [ ] 提供了开发方法指导
- [ ] 阐明了测试需求
- [ ] 设定了部署期望
- [ ] 识别了监控需求
- [ ] 指定了文档需求

## 8. 跨功能需求 (CROSS-FUNCTIONAL REQUIREMENTS)

### 8.1 数据需求

- [ ] 识别了数据实体和关系
- [ ] 指定了数据存储需求
- [ ] 定义了数据质量需求
- [ ] 识别了数据保留策略
- [ ] 解决了数据迁移需求（如适用）
- [ ] 计划了与需要它们的故事相关的迭代模式变更

### 8.2 集成需求

- [ ] 识别了外部系统集成
- [ ] 记录了 API 需求
- [ ] 指定了集成的身份验证
- [ ] 定义了数据交换格式
- [ ] 概述了集成测试需求

### 8.3 运营需求

- [ ] 设定了部署频率期望
- [ ] 定义了环境需求
- [ ] 识别了监控和警报需求
- [ ] 记录了支持需求
- [ ] 指定了性能监控方法

## 9. 清晰度和沟通 (CLARITY & COMMUNICATION)

### 9.1 文档质量

- [ ] 文档使用清晰、一致的语言
- [ ] 文档结构良好且组织有序
- [ ] 在必要时定义了技术术语
- [ ] 在有用时包括图表/可视化
- [ ] 文档适当版本化

### 9.2 利益相关者对齐

- [ ] 识别了关键利益相关者
- [ ] 纳入了利益相关者输入
- [ ] 解决了潜在分歧领域
- [ ] 建立了更新沟通计划
- [ ] 定义了批准流程

## PRD 和 EPIC 验证总结 (PRD & EPIC VALIDATION SUMMARY)

[[LLM: 最终 PM 检查清单报告生成

创建包括以下内容的综合验证报告：

1. 执行总结
    - 整体 PRD 完整性（百分比）
    - MVP 范围适当性（太大/刚好/太小）
    - 架构阶段准备就绪（准备就绪/几乎准备就绪/未准备就绪）
    - 最关键的差距或担忧

2. 类别分析表格
   用以下内容填写实际表格：
    - 状态：通过（90%+ 完成）、部分（60-89%）、失败（<60%）
    - 关键问题：阻塞进度的具体问题

3. 按优先级排序的主要问题
    - 阻塞者：架构师继续之前必须修复
    - 高：应该修复以提高质量
    - 中：会提高清晰度
    - 低：锦上添花

4. MVP 范围评估
    - 可能为真正 MVP 削减的功能
    - 缺少的基本功能
    - 复杂性担忧
    - 时间线现实性

5. 技术准备就绪
    - 技术约束清晰度
    - 识别的技术风险
    - 需要架构师调查的领域

6. 建议
    - 解决每个阻塞者的具体行动
    - 建议的改进
    - 下一步

呈现报告后，询问用户是否想要：

- 任何失败部分的详细分析
- 改进特定领域的建议
- 帮助优化 MVP 范围]]

### 类别状态

| 类别 (Category)                                    | 状态 (Status) | 关键问题 (Critical Issues) |
| -------------------------------------------------- | ------------- | -------------------------- |
| 1. 问题定义和上下文 (Problem Definition & Context) | _TBD_         |                            |
| 2. MVP 范围定义 (MVP Scope Definition)             | _TBD_         |                            |
| 3. 用户体验需求 (User Experience Requirements)     | _TBD_         |                            |
| 4. 功能需求 (Functional Requirements)              | _TBD_         |                            |
| 5. 非功能需求 (Non-Functional Requirements)        | _TBD_         |                            |
| 6. Epic 和故事结构 (Epic & Story Structure)        | _TBD_         |                            |
| 7. 技术指导 (Technical Guidance)                   | _TBD_         |                            |
| 8. 跨功能需求 (Cross-Functional Requirements)      | _TBD_         |                            |
| 9. 清晰度和沟通 (Clarity & Communication)          | _TBD_         |                            |

### 关键缺陷

（在验证期间填充）

### 建议

（在验证期间填充）

### 最终决定

- **准备架构**: PRD 和 epics 全面、结构良好，并准备好进行架构设计。
- **需要优化**: 需求文档需要额外工作来解决识别的缺陷。
