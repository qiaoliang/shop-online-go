# 架构师解决方案验证检查清单 (Architect Solution Validation Checklist)

此检查清单作为架构师在开发执行之前验证技术设计和架构的综合框架。架构师应系统性地处理每个项目，确保架构健壮、可扩展、安全并与产品需求对齐。

[[LLM: 初始化指令 - 必需工件

在继续此检查清单之前，确保您可以访问：

1. architecture.md - 主要架构文档（检查 docs/architecture.md）
2. prd.md - 产品需求文档用于需求对齐（检查 docs/prd.md）
3. frontend-architecture.md 或 fe-architecture.md - 如果这是 UI 项目（检查 docs/frontend-architecture.md）
4. 架构中引用的任何系统图
5. 如果可用，API 文档
6. 技术堆栈详情和版本规范

重要提示：如果任何必需文档缺失或无法访问，在继续之前立即询问用户其位置或内容。

项目类型检测：
首先，通过检查确定项目类型：

- 架构是否包括前端/UI 组件？
- 是否有 frontend-architecture.md 文档？
- PRD 是否提及用户界面或前端需求？

如果这是仅后端或仅服务项目：

- 跳过标记为 [[FRONTEND ONLY]] 的部分
- 特别关注 API 设计、服务架构和集成模式
- 在最终报告中注明由于项目类型跳过了前端部分

验证方法：
对于每个部分，您必须：

1. 深度分析 - 不要只是检查复选框，根据提供的文档彻底分析每个项目
2. 基于证据 - 验证时引用文档的具体章节或引述
3. 批判性思维 - 质疑假设并识别差距，而不仅仅是确认存在的内容
4. 风险评估 - 考虑每个架构决策可能出现的问题

执行模式：
询问用户是否想要通过检查清单：

- 逐节（交互模式）- 审查每个部分，呈现发现，在继续之前获得确认
- 一次性全部（综合模式）- 完成完整分析并在最后呈现综合报告]]

## 1. 需求对齐 (REQUIREMENTS ALIGNMENT)

[[LLM: 在评估此部分之前，花点时间从 PRD 完全理解产品的目的和目标。正在解决什么核心问题？用户是谁？关键成功因素是什么？在验证对齐时记住这些。对于每个项目，不要只是检查是否提到 - 验证架构提供了具体的技术解决方案。]]

### 1.1 功能需求覆盖

- [ ] 架构支持 PRD 中的所有功能需求
- [ ] 解决了所有 epics 和故事的技术方法
- [ ] 考虑了边界情况和性能场景
- [ ] 考虑了所有必需的集成
- [ ] 技术架构支持用户旅程

### 1.2 非功能需求对齐

- [ ] 用具体解决方案解决了性能需求
- [ ] 用方法记录了可扩展性考虑
- [ ] 安全需求有相应的技术控制
- [ ] 定义了可靠性和弹性方法
- [ ] 合规需求有技术实施

### 1.3 技术约束遵守

- [ ] 满足了 PRD 中的所有技术约束
- [ ] 遵循了平台/语言要求
- [ ] 适应了基础设施约束
- [ ] 解决了第三方服务约束
- [ ] 遵循了组织技术标准

## 2. 架构基础 (ARCHITECTURE FUNDAMENTALS)

[[LLM: 架构清晰度对成功实施至关重要。在审查此部分时，将系统可视化，就像向新开发者解释一样。是否有任何可能导致误解的歧义？AI 代理是否能够实施此架构而不混淆？寻找具体图表、组件定义和清晰的交互模式。]]

### 2.1 架构清晰度

- [ ] 用清晰图表记录了架构
- [ ] 定义了主要组件及其职责
- [ ] 映射了组件交互和依赖关系
- [ ] 清楚地说明了数据流
- [ ] 为每个组件指定了技术选择

### 2.2 关注点分离

- [ ] UI、业务逻辑和数据层之间的清晰边界
- [ ] 组件之间的职责干净分离
- [ ] 组件之间的接口定义良好
- [ ] 组件遵循单一职责原则
- [ ] 适当解决了横切关注点（日志、身份验证等）

### 2.3 设计模式和最佳实践

- [ ] 采用了适当的设计模式
- [ ] 遵循了行业最佳实践
- [ ] 避免了反模式
- [ ] 整个架构风格一致
- [ ] 记录并解释了模式使用

### 2.4 模块化和可维护性

- [ ] 系统分为内聚、松耦合的模块
- [ ] 组件可以独立开发和测试
- [ ] 变更可以本地化到特定组件
- [ ] 代码组织促进可发现性
- [ ] 架构专门为 AI 代理实施设计

## 3. 技术堆栈和决策 (TECHNICAL STACK & DECISIONS)

[[LLM: 技术选择有长期影响。对于每个技术决策，考虑：这是可能工作的最简单解决方案吗？我们是否过度工程？这会扩展吗？维护影响是什么？所选版本是否存在安全漏洞？验证定义了具体版本，而不是范围。]]

### 3.1 技术选择

- [ ] 选定的技术满足所有需求
- [ ] 具体定义了技术版本（不是范围）
- [ ] 用明确理由证明技术选择合理
- [ ] 记录了考虑的替代方案，包括利弊
- [ ] 选定的堆栈组件配合良好

### 3.2 前端架构 [[FRONTEND ONLY]]

[[LLM: 如果这是仅后端或仅服务项目，完全跳过此部分。仅当项目包括用户界面时才评估。]]

- [ ] 具体选择了 UI 框架和库
- [ ] 定义了状态管理方法
- [ ] 指定了组件结构和组织
- [ ] 概述了响应式/自适应设计方法
- [ ] 确定了构建和打包策略

### 3.3 后端架构

- [ ] 定义了 API 设计和标准
- [ ] 服务组织和边界清晰
- [ ] 指定了身份验证和授权方法
- [ ] 概述了错误处理策略
- [ ] 定义了后端扩展方法

### 3.4 数据架构

- [ ] 完全定义了数据模型
- [ ] 用理由选择了数据库技术
- [ ] 记录了数据访问模式
- [ ] 指定了数据迁移/种子方法
- [ ] 概述了数据备份和恢复策略

## 4. 前端设计和实施 [[FRONTEND ONLY]]

[[LLM: 对于仅后端项目，应完全跳过此部分。仅当项目包括用户界面时才评估。评估时，确保主架构文档和前端特定架构文档之间的对齐。]]

### 4.1 前端哲学和模式

- [ ] 框架和核心库与主架构文档对齐
- [ ] 清楚描述了组件架构（例如，原子设计）
- [ ] 状态管理策略适合应用程序复杂性
- [ ] 数据流模式一致且清晰
- [ ] 定义了样式方法并指定了工具

### 4.2 前端结构和组织

- [ ] 用 ASCII 图清楚记录了目录结构
- [ ] 组件组织遵循既定模式
- [ ] 文件命名约定明确
- [ ] 结构支持所选框架的最佳实践
- [ ] 关于新组件应放置位置的明确指导

### 4.3 组件设计

- [ ] 定义了组件模板/规范格式
- [ ] 良好记录了组件 props、状态和事件
- [ ] 识别了共享/基础组件
- [ ] 建立了组件可重用性模式
- [ ] 将可访问性要求内置到组件设计中

### 4.4 前端-后端集成

- [ ] 明确定义了 API 交互层
- [ ] 记录了 HTTP 客户端设置和配置
- [ ] API 调用的错误处理全面
- [ ] 服务定义遵循一致模式
- [ ] 与后端的身份验证集成清晰

### 4.5 路由和导航

- [ ] 指定了路由策略和库
- [ ] 路由定义表格全面
- [ ] 定义了路由保护机制
- [ ] 解决了深度链接考虑
- [ ] 导航模式一致

### 4.6 前端性能

- [ ] 定义了图像优化策略
- [ ] 记录了代码分割方法
- [ ] 建立了懒加载模式
- [ ] 指定了重新渲染优化技术
- [ ] 定义了性能监控方法

## 5. 弹性和运营准备就绪 (RESILIENCE & OPERATIONAL READINESS)

[[LLM: 生产系统以意外方式失败。在审查此部分时，考虑墨菲定律 - 什么可能出错？考虑真实场景：峰值负载期间会发生什么？当关键服务关闭时系统如何行为？运营团队能在凌晨 3 点诊断问题吗？寻找具体的弹性模式，而不仅仅是"错误处理"的提及。]]

### 5.1 错误处理和弹性

- [ ] 错误处理策略全面
- [ ] 在适当的地方定义了重试策略
- [ ] 为关键服务指定了断路器或回退
- [ ] 定义了优雅降级方法
- [ ] 系统可以从部分故障中恢复

### 5.2 监控和可观察性

- [ ] 定义了日志策略
- [ ] 指定了监控方法
- [ ] 识别了系统健康的关键指标
- [ ] 概述了警报阈值和策略
- [ ] 内置了调试和故障排除功能

### 5.3 性能和扩展

- [ ] 识别并解决了性能瓶颈
- [ ] 在适当的地方定义了缓存策略
- [ ] 指定了负载平衡方法
- [ ] 概述了水平和垂直扩展策略
- [ ] 提供了资源大小建议

### 5.4 部署和 DevOps

- [ ] 定义了部署策略
- [ ] 概述了 CI/CD 管道方法
- [ ] 指定了环境策略（开发、暂存、生产）
- [ ] 定义了基础设施即代码方法
- [ ] 概述了回滚和恢复程序

## 6. 安全和合规 (SECURITY & COMPLIANCE)

[[LLM: 安全不是可选的。以黑客心态审查此部分 - 有人如何利用此系统？还要考虑合规：是否有适用的行业特定法规？GDPR？HIPAA？PCI？确保架构主动解决这些问题。寻找具体的安全控制，而不仅仅是一般陈述。]]

### 6.1 身份验证和授权

- [ ] 明确定义了身份验证机制
- [ ] 指定了授权模型
- [ ] 如果需要，概述了基于角色的访问控制
- [ ] 定义了会话管理方法
- [ ] 解决了凭据管理

### 6.2 数据安全

- [ ] 指定了数据加密方法（静态和传输中）
- [ ] 定义了敏感数据处理程序
- [ ] 概述了数据保留和清除策略
- [ ] 如果需要，解决了备份加密
- [ ] 如果需要，指定了数据访问审计跟踪

### 6.3 API 和服务安全

- [ ] 定义了 API 安全控制
- [ ] 指定了速率限制和节流方法
- [ ] 概述了输入验证策略
- [ ] 解决了 CSRF/XSS 预防措施
- [ ] 指定了安全通信协议

### 6.4 基础设施安全

- [ ] 概述了网络安全设计
- [ ] 指定了防火墙和安全组配置
- [ ] 定义了服务隔离方法
- [ ] 应用了最小权限原则
- [ ] 概述了安全监控策略

## 7. 实施指导 (IMPLEMENTATION GUIDANCE)

[[LLM: 清晰的实施指导防止代价高昂的错误。在审查此部分时，想象您是第一天开始的开发者。他们拥有成为生产力所需的一切吗？编码标准是否足够清晰以在团队中保持一致性？寻找具体示例和模式。]]

### 7.1 编码标准和实践

- [ ] 定义了编码标准
- [ ] 指定了文档需求
- [ ] 概述了测试期望
- [ ] 定义了代码组织原则
- [ ] 指定了命名约定

### 7.2 测试策略

- [ ] 定义了单元测试方法
- [ ] 概述了集成测试策略
- [ ] 指定了 E2E 测试方法
- [ ] 概述了性能测试需求
- [ ] 定义了安全测试方法

### 7.3 前端测试 [[FRONTEND ONLY]]

[[LLM: 对于仅后端项目跳过此子部分。]]

- [ ] 定义了组件测试范围和工具
- [ ] 指定了 UI 集成测试方法
- [ ] 考虑了视觉回归测试
- [ ] 识别了可访问性测试工具
- [ ] 解决了前端特定的测试数据管理

### 7.4 开发环境

- [ ] 记录了本地开发环境设置
- [ ] 指定了必需的工具和配置
- [ ] 概述了开发工作流
- [ ] 定义了源代码控制实践
- [ ] 指定了依赖项管理方法

### 7.5 技术文档

- [ ] 定义了 API 文档标准
- [ ] 指定了架构文档需求
- [ ] 概述了代码文档期望
- [ ] 包括系统图和可视化
- [ ] 包括关键选择的决策记录

## 8. 依赖项和集成管理 (DEPENDENCY & INTEGRATION MANAGEMENT)

[[LLM: 依赖项通常是生产问题的来源。对于每个依赖项，考虑：如果它不可用会发生什么？是否有带安全补丁的更新版本？我们是否被锁定在供应商中？我们的应急计划是什么？验证具体版本和回退策略。]]

### 8.1 外部依赖项

- [ ] 识别了所有外部依赖项
- [ ] 定义了依赖项的版本策略
- [ ] 为关键依赖项指定了回退方法
- [ ] 解决了许可影响
- [ ] 概述了更新和修补策略

### 8.2 内部依赖项

- [ ] 清楚地映射了组件依赖项
- [ ] 解决了构建顺序依赖项
- [ ] 识别了共享服务和工具
- [ ] 消除了循环依赖项
- [ ] 定义了内部组件的版本策略

### 8.3 第三方集成

- [ ] 识别了所有第三方集成
- [ ] 定义了集成方法
- [ ] 解决了与第三方的身份验证
- [ ] 为集成故障指定了错误处理
- [ ] 考虑了速率限制和配额

## 9. AI 代理实施适用性 (AI AGENT IMPLEMENTATION SUITABILITY)

[[LLM: 此架构可能由 AI 代理实施。以极端清晰度审查。模式一致吗？复杂性最小化了吗？AI 代理会做出错误假设吗？记住：明确比隐含更好。寻找清晰的文件结构、命名约定和实施模式。]]

### 9.1 AI 代理的模块化

- [ ] 组件大小适合 AI 代理实施
- [ ] 组件之间的依赖项最小化
- [ ] 定义了组件之间的清晰接口
- [ ] 组件有单一、明确定义的职责
- [ ] 文件和代码组织针对 AI 代理理解优化

### 9.2 清晰度和可预测性

- [ ] 模式一致且可预测
- [ ] 复杂逻辑分解为更简单的步骤
- [ ] 架构避免过于聪明或晦涩的方法
- [ ] 为不熟悉的模式提供了示例
- [ ] 组件职责明确且清晰

### 9.3 实施指导

- [ ] 提供了详细的实施指导
- [ ] 定义了代码结构模板
- [ ] 记录了具体的实施模式
- [ ] 识别了常见陷阱并提供解决方案
- [ ] 在有用时提供了类似实施的参考

### 9.4 错误预防和处理

- [ ] 设计减少了实施错误的机会
- [ ] 定义了验证和错误检查方法
- [ ] 在可能的地方纳入了自愈机制
- [ ] 明确定义了测试模式
- [ ] 提供了调试指导

## 10. 可访问性实施 [[FRONTEND ONLY]]

[[LLM: 对于仅后端项目跳过此部分。可访问性是任何用户界面的核心要求。]]

### 10.1 可访问性标准

- [ ] 强调了语义 HTML 使用
- [ ] 提供了 ARIA 实施指南
- [ ] 定义了键盘导航需求
- [ ] 指定了焦点管理方法
- [ ] 解决了屏幕阅读器兼容性

### 10.2 可访问性测试

- [ ] 识别了可访问性测试工具
- [ ] 将测试流程集成到工作流中
- [ ] 指定了合规目标（WCAG 级别）
- [ ] 定义了手动测试程序
- [ ] 概述了自动化测试方法

[[LLM: 最终验证报告生成

现在您已完成检查清单，生成包括以下内容的综合验证报告：

1. 执行总结
    - 整体架构准备就绪（高/中/低）
    - 识别的关键风险
    - 架构的关键优势
    - 项目类型（全栈/前端/后端）和评估的部分

2. 部分分析
    - 每个主要部分的通过率（通过项目的百分比）
    - 最令人担忧的失败或差距
    - 需要立即关注的部分
    - 注明由于项目类型跳过的任何部分

3. 风险评估
    - 按严重性排序的前 5 个风险
    - 每个风险的缓解建议
    - 解决问题的时间线影响

4. 建议
    - 开发前必须修复的项目
    - 为更好质量应该修复的项目
    - 锦上添花的改进

5. AI 实施准备就绪
    - AI 代理实施的具体担忧
    - 需要额外澄清的领域
    - 需要解决的复杂性热点

6. 前端特定评估（如适用）
    - 前端架构完整性
    - 主架构和前端架构文档之间的对齐
    - UI/UX 规范覆盖
    - 组件设计清晰度

呈现报告后，询问用户是否想要任何特定部分的详细分析，特别是那些有警告或失败的部分。]]
