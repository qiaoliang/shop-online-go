# 架构师解决方案验证检查清单

此检查清单作为一个全面的框架，供架构师在开发执行之前验证技术设计和架构。架构师应系统地完成每个项目，确保架构稳健、可扩展、安全，并与产品需求保持一致。

[[LLM: 初始化说明 - 所需工件

在进行此检查清单之前，请确保您可以访问：

1. architecture.md - 主要架构文档（检查 docs/architecture.md）
2. prd.md - 产品需求文档以确保需求对齐（检查 docs/prd.md）
3. frontend-architecture.md 或 fe-architecture.md - 如果这是一个 UI 项目（检查 docs/frontend-architecture.md）
4. 架构中引用的任何系统图
5. 如果可用，API 文档
6. 技术栈详细信息和版本规范

重要：如果缺少或无法访问任何所需文档，请立即询问用户其位置或内容，然后再继续。

项目类型检测：
首先，通过检查确定项目类型：

- 架构是否包括前端/UI 组件？
- 是否有 frontend-architecture.md 文档？
- PRD 是否提到用户界面或前端需求？

如果这是一个仅后端或仅服务项目：

- 跳过标记为 [[FRONTEND ONLY]] 的部分
- 重点关注 API 设计、服务架构和集成模式
- 在最终报告中注明由于项目类型而跳过前端部分

验证方法：
对于每个部分，您必须：

1. 深度分析 - 不仅仅是勾选框，根据提供的文档彻底分析每个项目
2. 基于证据 - 验证时引用文档中的具体部分或引述
3. 批判性思维 - 质疑假设并识别差距，而不仅仅是确认存在的内容
4. 风险评估 - 考虑每个架构决策可能出错的地方

执行模式：
询问用户是否希望逐节完成检查清单：

- 逐节（互动模式） - 审查每个部分，提出发现，获得确认后再继续
- 一次性（全面模式） - 完成全面分析并在最后呈现全面报告]]

## 1. 需求对齐

[[LLM: 在评估此部分之前，花点时间充分了解产品的目的和目标。解决的核心问题是什么？用户是谁？关键成功因素是什么？在验证对齐时牢记这些。对于每个项目，不仅仅是检查是否提到 - 验证架构是否提供具体的技术解决方案。]]

### 1.1 功能需求覆盖

- [ ] 架构支持 PRD 中的所有功能需求
- [ ] 解决所有史诗和故事的技术方法
- [ ] 考虑边缘情况和性能场景
- [ ] 考虑所有必需的集成
- [ ] 用户旅程由技术架构支持

### 1.2 非功能需求对齐

- [ ] 性能需求通过具体解决方案解决
- [ ] 记录可扩展性考虑及方法
- [ ] 安全需求有相应的技术控制
- [ ] 定义可靠性和弹性方法
- [ ] 合规需求有技术实现

### 1.3 技术约束遵循

- [ ] 满足 PRD 中的所有技术约束
- [ ] 遵循平台/语言要求
- [ ] 适应基础设施约束
- [ ] 解决第三方服务约束
- [ ] 遵循组织技术标准

## 2. 架构基础

[[LLM: 架构清晰度对于成功实施至关重要。在审查此部分时，想象您在向新开发人员解释系统。是否有任何可能导致误解的模糊之处？AI 代理是否能够毫不困惑地实施此架构？寻找具体的图表、组件定义和清晰的交互模式。]]

### 2.1 架构清晰度

- [ ] 使用清晰的图表记录架构
- [ ] 定义主要组件及其职责
- [ ] 映射组件交互和依赖关系
- [ ] 清晰地说明数据流
- [ ] 为每个组件指定技术选择

### 2.2 关注点分离

- [ ] 明确划分 UI、业务逻辑和数据层之间的界限
- [ ] 在组件之间清晰划分职责
- [ ] 定义组件之间的接口
- [ ] 组件遵循单一职责原则
- [ ] 正确处理横切关注点（日志记录、身份验证等）

### 2.3 设计模式和最佳实践

- [ ] 采用适当的设计模式
- [ ] 遵循行业最佳实践
- [ ] 避免反模式
- [ ] 整个架构风格一致
- [ ] 记录并解释模式使用

### 2.4 模块化和可维护性

- [ ] 系统划分为内聚、松耦合的模块
- [ ] 组件可以独立开发和测试
- [ ] 更改可以局限于特定组件
- [ ] 代码组织促进可发现性
- [ ] 专门为 AI 代理实施设计的架构

## 3. 技术栈和决策

[[LLM: 技术选择具有长期影响。对于每个技术决策，考虑：这是最简单的可行解决方案吗？我们是否过度设计？这会扩展吗？维护的影响是什么？所选版本是否存在安全漏洞？验证定义了具体版本，而不是范围。]]

### 3.1 技术选择

- [ ] 所选技术满足所有需求
- [ ] 明确定义技术版本（而不是范围）
- [ ] 通过明确的理由证明技术选择的合理性
- [ ] 记录考虑的替代方案及其优缺点
- [ ] 所选栈组件协同工作良好

### 3.2 前端架构 [[FRONTEND ONLY]]

[[LLM: 如果这是一个仅后端或仅服务项目，请跳过整个部分。仅在项目包括用户界面时评估。]]

- [ ] 明确选择 UI 框架和库
- [ ] 定义状态管理方法
- [ ] 指定组件结构和组织
- [ ] 概述响应式/自适应设计方法
- [ ] 确定构建和打包策略

### 3.3 后端架构

- [ ] 定义 API 设计和标准
- [ ] 服务组织和边界清晰
- [ ] 指定身份验证和授权方法
- [ ] 概述错误处理策略
- [ ] 定义后端扩展方法

### 3.4 数据架构

- [ ] 完全定义数据模型
- [ ] 选择数据库技术并提供理由
- [ ] 记录数据访问模式
- [ ] 指定数据迁移/播种方法
- [ ] 概述数据备份和恢复策略

## 4. 前端设计和实施 [[FRONTEND ONLY]]

[[LLM: 对于仅后端项目，跳过整个部分。仅在项目包括用户界面时评估。评估时，确保主架构文档与前端特定架构文档之间的一致性。]]

### 4.1 前端哲学和模式

- [ ] 框架和核心库与主架构文档一致
- [ ] 明确描述组件架构（例如，原子设计）
- [ ] 状态管理策略适合应用程序复杂性
- [ ] 数据流模式一致且清晰
- [ ] 定义样式方法并指定工具

### 4.2 前端结构和组织

- [ ] 使用 ASCII 图清晰记录目录结构
- [ ] 组件组织遵循声明的模式
- [ ] 明确文件命名约定
- [ ] 结构支持所选框架的最佳实践
- [ ] 提供关于新组件应放置位置的明确指导

### 4.3 组件设计

- [ ] 定义组件模板/规范格式
- [ ] 组件属性、状态和事件记录良好
- [ ] 确定共享/基础组件
- [ ] 建立组件可重用性模式
- [ ] 在组件设计中内置无障碍性要求

### 4.4 前端-后端集成

- [ ] 明确定义 API 交互层
- [ ] 记录 HTTP 客户端设置和配置
- [ ] API 调用的错误处理全面
- [ ] 服务定义遵循一致的模式
- [ ] 明确与后端的身份验证集成

### 4.5 路由和导航

- [ ] 指定路由策略和库
- [ ] 路由定义表全面
- [ ] 定义路由保护机制
- [ ] 解决深度链接考虑
- [ ] 导航模式一致

### 4.6 前端性能

- [ ] 定义图像优化策略
- [ ] 记录代码拆分方法
- [ ] 建立延迟加载模式
- [ ] 指定重新渲染优化技术
- [ ] 定义性能监控方法

## 5. 弹性和操作准备

[[LLM: 生产系统以意想不到的方式失败。在审查此部分时，考虑墨菲定律 - 可能会出错的地方？考虑现实世界的场景：高峰负载期间会发生什么？当关键服务停机时系统如何表现？运营团队能否在凌晨 3 点诊断问题？寻找具体的弹性模式，而不仅仅是“错误处理”的提及。]]

### 5.1 错误处理和弹性

- [ ] 错误处理策略全面
- [ ] 在适当的地方定义重试策略
- [ ] 为关键服务指定断路器或回退
- [ ] 定义优雅降级方法
- [ ] 系统可以从部分故障中恢复

### 5.2 监控和可观察性

- [ ] 定义日志记录策略
- [ ] 指定监控方法
- [ ] 确定系统健康的关键指标
- [ ] 概述警报阈值和策略
- [ ] 内置调试和故障排除能力

### 5.3 性能和扩展

- [ ] 识别并解决性能瓶颈
- [ ] 在适当的地方定义缓存策略
- [ ] 指定负载均衡方法
- [ ] 概述水平和垂直扩展策略
- [ ] 提供资源大小建议

### 5.4 部署和 DevOps

- [ ] 定义部署策略
- [ ] 概述 CI/CD 管道方法
- [ ] 指定环境策略（开发、暂存、生产）
- [ ] 定义基础设施即代码方法
- [ ] 概述回滚和恢复程序

## 6. 安全和合规

[[LLM: 安全不是可选的。以黑客的心态审查此部分 - 有人如何利用此系统？还要考虑合规性：是否有适用的行业特定法规？GDPR？HIP 